# vim:se syn=tcl:
#
use cc cc-shared cc-lib

options {
    no-debug=0 => "Disable debug build options."
    loud=0 => "Enables 'loud' build mode."
}


# autosetup interceps 'debug' and 'enable-debug' flags :/
#    prefix:=[get-env HOME /usr/local] -> "Installation prefix."

#cc-check-c11

cc-check-sizeof "void *"

if {![cc-check-includes zlib.h] ||
    ![cc-check-function-in-lib compress z]} {
    user-error "Missing functional zlib"
}
cc-check-function-in-lib iconv iconv

########################################################################
# Checks for C99 via (__STDC_VERSION__ >= 199901L). Returns 1 if so, 0
# 0 if not.
proc cc-check-c99 {} {
    msg-checking "Checking for C99 via __STDC_VERSION__... "
    if {[cctest -code {
        #if !defined(__STDC_VERSION__) || __STDC_VERSION__<199901L
        # error "Not C99"
        #endif
    }]} {
        msg-result "got C99"
        return 1
    }
    return 0
}

# The compiler may be able to run in C99 mode without -std=c99, but we
# check for that flag anyway because without it we might inadvertently
# be compiling against a newer C standard for purposes of flags like
# -pedantic
set CC_FLAG_C99 {-std=c99}
if {![cc-check-flags $CC_FLAG_C99]} {
    set CC_FLAG_C99 {}
}
if {![cc-check-c99]} {
    user-error "As of 2021-02-21, libfossil requires C99."
}

define CC_FLAG_C99 $CC_FLAG_C99

if {![get-define FSL_ENABLE_MODULE_LOADER]} {
    msg-result {No usable module loading library found. No worries, because we won't have a module system yet. :-D}
} else {
    msg-result {Found a module loader. Now we just need something to do with it.}
}

########################################################################
# A proxy for cc-check-function-in-lib which "undoes" any changes that
# routine makes to the LIBS define.
proc my-check-function-in-lib {function libs {otherlibs {}}} {
    set _LIBS [get-define LIBS]
    set found [cc-check-function-in-lib $function $libs $otherlibs]
    define LIBS $_LIBS
    return $found
}

########################################################################
# readline is only used (if at all) by s2sh. If it's not available, we
# fall back to a tree-local copy of the BSD-licensed linenoise editing
# library.
if {[cc-check-includes readline/readline.h] &&
    [my-check-function-in-lib readline readline]} {
    define FSL_ENABLE_READLINE 1
    define FSL_ENABLE_LINENOISE 0
    msg-result "Enabling libreadline for f-s2sh line editing."
} else {
    msg-result "libreadline not found. f-s2sh will use the linenoise line editor."
    define FSL_ENABLE_READLINE 0
    define FSL_ENABLE_LINENOISE 1
    define lib_readline ""
}

# cc-check-functions getcwd fopen
cc-check-functions opendir stat pipe inet_ntop getaddrinfo
#msg-result [cc-check-functions lstat]

if {[cc-check-functions lstat]} {
    # for lstat() on Linux and FreeBSD:
    define _XOPEN_SOURCE 600
    # alternate for lstat() on Linux:
    # define _BSD_SOURCE 1
    # ^^^^ causes warning (-Werror breakage) with glibc >=2.20
    define _DEFAULT_SOURCE 1
    define _POSIX_C_SOURCE 200112L
}


# Find some tools
cc-check-tools ar ranlib strip

set extra_objs {}

if {[find-an-executable cygpath] ne "" || $::tcl_platform(os)=="Windows NT"} {
  set cFlags {}
} else {
  set cFlags {-fPIC}
}

if {[opt-bool no-debug]} {
    msg-result "Non-debug build."
    set cFlags "$cFlags -O2"
} else {
    msg-result "Debug build enabled. Use --no-debug to build in non-debug mode."
    set cFlags "$cFlags -g -DDEBUG -O0"
}

########################################################################
# Curses!
set LIB_CURSES ""
puts "Looking for \[n]curses..."
define HAVE_CURSES_H [cc-check-includes curses.h]
if {[get-define HAVE_CURSES_H]} {
    # Linux has -lncurses, BSD -lcurses. Both have <curses.h>
    msg-result "Found curses.h"
    if {[my-check-function-in-lib waddnwstr ncursesw]} {
        msg-result "Found -lncursesw"
        set LIB_CURSES -lncursesw
    } elseif {[my-check-function-in-lib initscr ncurses]} {
        msg-result "Found -lncurses"
        set LIB_CURSES -lncurses
    } elseif {[my-check-function-in-lib initscr curses]} {
        msg-result "Found -lcurses"
        set LIB_CURSES -lcurses
    }
}
if {"" eq $LIB_CURSES} {
    user-error "!Curses! Foiled again!"
}
define LIB_CURSES $LIB_CURSES
unset LIB_CURSES


puts "Checking for compile_commands.json support..."
if {[cctest -lang c -cflags {/dev/null -MJ} -source {}]} {
    msg-result "Compiler supports compile_commands.json."
    define MAKE_COMPILATION_DB yes
} else {
    msg-result "Compiler does not support compile_commands.json."
    define MAKE_COMPILATION_DB no
}

define CFLAGS $cFlags

if {[opt-bool loud]} {
    define BUILD_QUIETLY 0
    puts "Using 'loud' build mode."
} else {
    define BUILD_QUIETLY 1
    puts "Enabling quiet build mode. Use --loud to enable loud mode."
}

# Creates mkefile(-like) file $name from $name.in but explicitly makes
# the output read-only, to avoid inadvertent editing (who, me?).
proc makeFromDotIn {name} {
    catch { exec chmod u+w $name }
    make-template $name.in $name
    catch { exec chmod u-w $name }
}
# Each generated Makefile requires an input file with a .in extension:
set makefiles {
    config.make
    Makefile
    src/Makefile
    fnc/Makefile
}
foreach {f} $makefiles {
    makeFromDotIn $f
}

if {0} {
    # Achtung: ordering of the -bare/-str options here is important
    # because of the mixed use of strings and integers for #defines...
    make-config-header include/fossil-scm/autoconfig.h \
        -none {DOXYGEN_*} \
        -bare {HAVE_*  FSL_ENABLE_* _DEFAULT_SOURCE _XOPEN_SOURCE} \
        -str {FSL_* PACKAGE_*}
}
