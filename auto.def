# vim:se syn=tcl:
#
use cc cc-shared cc-lib

options {
    no-debug=0 => "Disable debug build options."
    loud=0 => "Enables 'loud' build mode."
}


# autosetup interceps 'debug' and 'enable-debug' flags :/
#    prefix:=[get-env HOME /usr/local] -> "Installation prefix."

#cc-check-c11

cc-check-sizeof "void *"

if {![cc-check-includes zlib.h] ||
    ![cc-check-function-in-lib compress z]} {
    user-error "Missing functional zlib"
}
cc-check-function-in-lib iconv iconv

########################################################################
# Checks for C99 via (__STDC_VERSION__ >= 199901L). Returns 1 if so, 0
# 0 if not.
proc cc-check-c99 {} {
    msg-checking "Checking for C99 via __STDC_VERSION__... "
    if {[cctest -code {
        #if !defined(__STDC_VERSION__) || __STDC_VERSION__<199901L
        # error "Not C99"
        #endif
    }]} {
        msg-result "got C99"
        return 1
    }
    return 0
}

# The compiler may be able to run in C99 mode without -std=c99, but we
# check for that flag anyway because without it we might inadvertently
# be compiling against a newer C standard for purposes of flags like
# -pedantic
set CC_FLAG_C99 {-std=c99}
if {![cc-check-flags $CC_FLAG_C99]} {
    set CC_FLAG_C99 {}
}
if {![cc-check-c99]} {
    user-error "As of 2021-02-21, libfossil requires C99."
}

define CC_FLAG_C99 $CC_FLAG_C99

if {![get-define FSL_ENABLE_MODULE_LOADER]} {
    msg-result {No usable module loading library found. No worries, because we won't have a module system yet. :-D}
} else {
    msg-result {Found a module loader. Now we just need something to do with it.}
}

########################################################################
# A proxy for cc-check-function-in-lib which "undoes" any changes that
# routine makes to the LIBS define.
proc my-check-function-in-lib {function libs {otherlibs {}}} {
    set _LIBS [get-define LIBS]
    set found [cc-check-function-in-lib $function $libs $otherlibs]
    define LIBS $_LIBS
    return $found
}

# cc-check-functions getcwd fopen
cc-check-functions opendir stat pipe inet_ntop getaddrinfo
#msg-result [cc-check-functions lstat]

if {[cc-check-functions lstat]} {
    # for lstat() on Linux and FreeBSD:
    define _XOPEN_SOURCE 600
    # alternate for lstat() on Linux:
    # define _BSD_SOURCE 1
    # ^^^^ causes warning (-Werror breakage) with glibc >=2.20
    define _DEFAULT_SOURCE 1
    define _POSIX_C_SOURCE 200112L
}


# Find some tools
cc-check-tools ar ranlib strip

set extra_objs {}

if {[find-an-executable cygpath] ne "" || $::tcl_platform(os)=="Windows NT"} {
  set cFlags {}
} else {
  set cFlags {-fPIC}
}

if {[opt-bool no-debug]} {
    msg-result "Non-debug build."
    set cFlags "$cFlags -O2"
} else {
    msg-result "Debug build enabled. Use --no-debug to build in non-debug mode."
    set cFlags "$cFlags -g -DDEBUG -O0"
}


set pcBin [find-an-executable pkg-config]
if {"" eq $pcBin} {
    puts {pkg-config not found, so making some guesses about
available packages.}
}
########################################################################
# Curses!
set LIB_CURSES ""
set CFLAGS_CURSES ""
puts "Looking for \[n]curses..."
if {"" ne $pcBin} {
    set np ""
    foreach p {ncursesw ncurses} {
        if {[catch {exec $pcBin --exists $p}]} {
            continue
        }
        set np $p
        puts "Using pkg-config curses package \[$p]"
        break
    }
    if {"" ne $np} {
        set ppanel ""
        if {"ncursesw" eq $np} {
            if {![catch {exec $pcBin --exists panelw}]} {
                set ppanel panelw
            }
        }
        if {"" eq $ppanel && ![catch {exec $pcBin --exists panel}]} {
            set ppanel panel
        }
        set CFLAGS_CURSES [exec $pcBin --cflags $np]
        set LIB_CURSES [exec $pcBin --libs $np]
        if {"" eq $ppanel} {
            # Apparently Mac brew has pkg-config for ncursesw but not
            # panel/panelw, but hard-coding -lpanel seems to work on
            # that platform.
            append LIB_CURSES " -lpanel"
        } else {
            append LIB_CURSES " " [exec $pcBin --libs $ppanel]
            # append CFLAGS_CURSES " " [exec $pcBin --cflags $ppanel]
            # ^^^^ appending the panel cflags will end up duplicating
            # at least one -D flag from $np's cflags, leading to
            # "already defined" errors at compile-time. Sigh. Note, however,
            # that $ppanel's cflags have flags which $np's do not, so we
            # may need to include those flags anyway and manually perform
            # surgery on the list to remove dupes. Sigh.
        }
    }
}

if {"" eq $LIB_CURSES} {
    puts "Guessing curses location (will fail for exotic locations)..."
    define HAVE_CURSES_H [cc-check-includes curses.h]
    if {[get-define HAVE_CURSES_H]} {
        # Linux has -lncurses, BSD -lcurses. Both have <curses.h>
        msg-result "Found curses.h"
        if {[my-check-function-in-lib waddnwstr ncursesw]} {
            msg-result "Found -lncursesw"
            set LIB_CURSES "-lncursesw -lpanelw"
        } elseif {[my-check-function-in-lib initscr ncurses]} {
            msg-result "Found -lncurses"
            set LIB_CURSES "-lncurses -lpanel"
        } elseif {[my-check-function-in-lib initscr curses]} {
            msg-result "Found -lcurses"
            set LIB_CURSES "-lcurses -lpanel"
        }
    }
}
if {"" eq $LIB_CURSES} {
    user-error "!Curses! Foiled again!"
} else {
    puts {
        ************************************************************
        If your build fails due to missing functions such as
        waddwstr(), make sure you have the ncursesW development
        package installed. Some platforms combine the "w" and non-w
        curses builds and some don't.

        The package may have a name such as libncursesw5-dev or
        some such.
        ************************************************************
    }
}
define LIB_CURSES $LIB_CURSES
define CFLAGS_CURSES $CFLAGS_CURSES
unset LIB_CURSES
unset CFLAGS_CURSES


puts "Checking for compile_commands.json support..."
if {[cctest -lang c -cflags {/dev/null -MJ} -source {}]} {
    msg-result "Compiler supports compile_commands.json."
    define MAKE_COMPILATION_DB yes
} else {
    msg-result "Compiler does not support compile_commands.json."
    define MAKE_COMPILATION_DB no
}

define CFLAGS $cFlags

if {[opt-bool loud]} {
    define BUILD_QUIETLY 0
    puts "Using 'loud' build mode."
} else {
    define BUILD_QUIETLY 1
    puts "Enabling quiet build mode. Use --loud to enable loud mode."
}

# Creates mkefile(-like) file $name from $name.in but explicitly makes
# the output read-only, to avoid inadvertent editing (who, me?).
proc makeFromDotIn {name} {
    catch { exec chmod u+w $name }
    make-template $name.in $name
    catch { exec chmod u-w $name }
}
# Each generated Makefile requires an input file with a .in extension:
set makefiles {
    config.make
    Makefile
    src/Makefile
    fnc/Makefile
}
foreach {f} $makefiles {
    makeFromDotIn $f
}

if {0} {
    # Achtung: ordering of the -bare/-str options here is important
    # because of the mixed use of strings and integers for #defines...
    make-config-header include/fossil-scm/autoconfig.h \
        -none {DOXYGEN_*} \
        -bare {HAVE_*  FSL_ENABLE_* _DEFAULT_SOURCE _XOPEN_SOURCE} \
        -str {FSL_* PACKAGE_*}
}
