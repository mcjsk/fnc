// Alias our requirejs workalike for convenience...
assert Fossil.require /* gets set via f-s2sh.s2 */;
const R = Fossil.require;
if(!R.fsl){
    /* kludge to avoid requiring a CLI flag to provide a repo */
    const f = R(['fsl/context']).0;
    affirm f === R.fsl;
    affirm R.fsl.db;
    R.fsl.openCheckout();
}/* else a downstream module will open the repo as needed */


print('require() plugins:', R.plugins.propertyKeys());

// Use it like requirejs:
R([// Resources to load: those with a '!' are "plugins", not script files
    'fsl/wikiByName!download',
    'text!require-demo.s2',
    'fsl/blob!rid:1',
    'fsl/manifest!trunk'
  ], // Callback to pass the resources to:
  function(page, thisScript, rid1, trunk){
      print(__FLC, typeinfo(name page), typeinfo(name thisScript), typeinfo(name rid1));
      print("Wiki page [", page.L,"] is", page.W.lengthBytes(),"bytes long.");
      print("This script is",thisScript.lengthBytes(),"bytes long.");
      print("RID 1's manifest is", rid1.length(), "bytes long.");
      print("trunk has", trunk.F.length(), "F-cards.");
  });


R(['fsl/context', // shared/cached Fossil.Context instance
   'fsl/wiki/util' // various Wiki utilities
  ],
  function(fsl, wikiUtil){
      var pages = [];
      wikiUtil.getPageNames().
          eachIndex(proc(name){
              pages[] = fsl.loadManifest( wikiUtil.getLatestRid(name) );
          });
      print(pages.length(),"wiki pages found:");
      const j2h = Fossil.time.julianToHuman;
      0 && pages.sort(function(l,r){
          // It seems we have a bug in/around cwal_array_sort_stateful(), as
          // the sorted result here is very unexpected. But i'm too tired
          // to fight it.
          // print('',j2h(r.D), '\n', j2h(l.D), j2h(r.D).compare(j2h(l.D)));
          //return j2h(r.D).compare(j2h(l.D));
          //print(r.D, l.D, r.D.compare(l.D));
          //return (r.D * 10000000).toInt() - (l.D * 10000000).toInt();
          return r.D.compare(l.D);
      });
      pages.eachIndex(proc(page){
          print( "    %1$-25s @ %2$s by %3$s %4$d bytes".
                 applyFormat(page.L,
                             j2h(page.D),
                             page.U,
                             page.W.lengthBytes()));
      });
      print("");
  });

R(['fsl/timeline/basic', // list of most recent rows from the event table
   'ostream' // output utility for fans of C++
  ],
  proc(tl, os){
      os << "Most recent timeline entries:\n";
      tl.eachIndex(proc(v){
          os << v.type << ' ' << v.uuid.substr(0,10)
              << ' @ ' << Fossil.time.julianToHuman(v.mtime)
              << ' by '
              << (v.euser ||| v.user)
              << '\n\t'
              << (v.ecomment ||| v.comment)
              << '\n';
      });
      os << '\n';
  });

// An auto-loaded (not pre-registered) plugin:
R(['demo!foo',
   'demo!bar?a=1&b&c=hi there'
  ],
  proc(demo, d2){
      print("Demo auto-loaded plugin:",demo);
      assert d2 === demo /* because of how this particular plugin works */;
      assert 2 === demo.counter;
      assert 'bar' === demo.lastArgs.0;
      assert 'hi there' === demo.lastArgs.1.c;
  });

if(Fossil.file.isFile('cgimod.so')){
    R(['dll!cgimod', // the CGI API (loadable module)
       'dll!cgimod', // same instance (cached)
       'dll!cgimod?checkingCache' // params bypass caching
       /* reminder: 2 instances of this module is semantically
          invalid in a real CGI context. We're just testing that
          R()'s docs regarding caching matches its behaviour. */
      ],
      proc(cgi, cgi2, cgi3){
          assert cgi === cgi2;
          assert cgi !== cgi3;
             print("Loaded cgi module: "+cgi);
      });
}else{
    print("cgimod DLL not found.");
}
